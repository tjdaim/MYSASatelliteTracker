<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sich-2-1 Reentry Tracker</title>
    <style>
        body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background-color: #000; color: #fff; overflow: hidden; }
        canvas { display: block; }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 320px;
            font-size: 14px;
            line-height: 1.6;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 10;
        }
        #info-panel h1 {
            font-size: 24px;
            margin: 0 0 10px 0;
            color: #4c82f7;
        }
        #info-panel p { margin: 5px 0; }
        #info-panel span { font-weight: bold; color: #a8bff7; }
        .loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 8px solid #f3f3f3;
            border-top: 8px solid #4c82f7;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 12px;
            text-align: right;
            z-index: 10;
        }
        .satellite-label {
            color: #ffffff;
            font-family: sans-serif;
            font-size: 12px;
            padding: 2px 5px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            pointer-events: none; /* Important so it doesn't interfere with mouse controls */
        }

        /* Mobile Optimization */
        @media (max-width: 768px) {
            #info-panel {
                width: auto;
                left: 10px;
                right: 10px;
                top: 10px;
                font-size: 12px;
            }

            #info-panel h1 {
                font-size: 20px;
            }
            
            #info-panel h4 {
                font-size: 14px;
            }

            #instructions {
                width: auto;
                left: 10px;
                right: 10px;
                bottom: 10px;
                text-align: center;
                padding: 8px;
            }
            
            .satellite-label {
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="loader" class="loader"></div>
    <div id="info-panel" style="display: none;">
        <h1>Sich-2-1 Reentry Simulation</h1>
        <p>NORAD ID: <span>51030</span></p>
        <p>Status: <span id="status">Simulating predicted trajectory...</span></p>
        <p>Latitude: <span id="lat">0.00</span>°</p>
        <p>Longitude: <span id="lon">0.00</span>°</p>
        <p>Altitude: <span id="alt">0.00</span> km</p>
        <p>Velocity: <span id="vel">0.00</span> km/s</p>
        <div id="malaysia-pass-info" style="margin-top: 10px;">
            <h4 style="margin: 5px 0; color: #4c82f7;">Predicted Future Passes (UTC+8)</h4>
            <ul id="pass-list" style="padding-left: 20px; margin: 0; font-size: 12px; max-height: 100px; overflow-y: auto;">
                <li>Calculating...</li>
            </ul>
        </div>
    </div>
    <div id="instructions" style="display: none;">
        <p><strong>Controls:</strong></p>
        <p>Left-click + Drag: Rotate</p>
        <p>Scroll / Right-click + Drag: Zoom</p>
        <p style="margin-top: 10px; font-style: italic;">version 1.0 developed by Dr. Terence Jerome Daim, Malaysian Space Agency (MYSA)</p>
    </div>

    

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/satellite.js/4.1.4/satellite.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <script>
        let scene, camera, renderer, css2dRenderer, earth, satelliteObj, controls, clouds, groundTrackIcon;
        let simulationTime;
        const clock = new THREE.Clock();
        let lastGeodeticData = {};

        // TLE (Two-Line Element set) for Sich-2-1 - this is a recent one indicating orbital decay.
        const tleLine1 = '1 51030U 22002AY 25278.83689685 .01786693 23671-5 10785-2 0 9999';
        const tleLine2 = '2 51030 97.3019  2.7254 0007382 256.9548 103.0916 16.18284853208184';
        const satrec = satellite.twoline2satrec(tleLine1, tleLine2);

        // Earth radius in km
        const earthRadius = 6371;
        const sceneScale = 1000; // Scale down scene to avoid floating point issues

        const MALAYSIA_BOUNDS = { minLat: 0, maxLat: 8, minLon: 99, maxLon: 120 };
        
        // User's provided current time in UTC
        const currentUserTimeUTC = new Date('2025-10-08T11:49:00Z'); // 7:49 PM MYT on Oct 8 is 11:49 AM UTC

        function tleEpochToDate(satrec) {
            const year = satrec.epochyr < 57 ? satrec.epochyr + 2000 : satrec.epochyr + 1900;
            const day = satrec.epochdays;
            const ms_per_day = 86400000; // 24 * 60 * 60 * 1000
            const jan1 = Date.UTC(year, 0, 1);
            const epoch_ms = jan1 + (day - 1) * ms_per_day;
            return new Date(epoch_ms);
        }

        function init() {
            simulationTime = tleEpochToDate(satrec);
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // Set background to black
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = earthRadius / sceneScale * 2.5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            
            css2dRenderer = new THREE.CSS2DRenderer();
            css2dRenderer.setSize(window.innerWidth, window.innerHeight);
            css2dRenderer.domElement.style.position = 'absolute';
            css2dRenderer.domElement.style.top = '0px';
            css2dRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(css2dRenderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 3, 5);
            scene.add(directionalLight);
            
            const manager = new THREE.LoadingManager();
            manager.onLoad = () => setupScene(loadedTextures);
            manager.onError = (url) => {
                console.error(`There was an error loading ${url}`);
                handleTextureError();
            };

            const textureLoader = new THREE.TextureLoader(manager);
            const loadedTextures = {
                earth: textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/2_no_clouds_4k.jpg'),
                clouds: textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/fair_clouds_4k.png'),
            };

            window.addEventListener('resize', onWindowResize, false);
        }

        function setupScene(textures) {
            const earthGeometry = new THREE.SphereGeometry(earthRadius / sceneScale, 64, 64);
            const earthMaterial = new THREE.MeshPhongMaterial({ map: textures.earth });
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            scene.add(earth);

            const cloudGeometry = new THREE.SphereGeometry(earthRadius / sceneScale + 5 / sceneScale, 64, 64);
            const cloudMaterial = new THREE.MeshPhongMaterial({
                map: textures.clouds,
                transparent: true,
                opacity: 0.4,
                blending: THREE.AdditiveBlending
            });
            clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
            scene.add(clouds);

            createSatelliteObjects();
            finalizeScene();
        }

        function handleTextureError() {
            console.error("Failed to load one or more textures. Using a basic material.");
            const earthGeometry = new THREE.SphereGeometry(earthRadius / sceneScale, 64, 64);
            const earthMaterial = new THREE.MeshPhongMaterial({ color: 0x2c7bff });
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            scene.add(earth);
            
            createSatelliteObjects();
            finalizeScene();
        }

        function createSatelliteObjects() {
             // Satellite Object (Red Circle)
            const satGeometry = new THREE.SphereGeometry(15 / sceneScale, 16, 16);
            const satMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            satelliteObj = new THREE.Mesh(satGeometry, satMaterial);
            scene.add(satelliteObj);

            // Satellite Label
            const labelDiv = document.createElement('div');
            labelDiv.className = 'satellite-label';
            labelDiv.textContent = 'Sich-2-1';
            const satelliteLabel = new THREE.CSS2DObject(labelDiv);
            satelliteLabel.position.set(0, 25 / sceneScale, 0); // Offset from the sphere
            satelliteObj.add(satelliteLabel);

            // Ground Track Icon (Cyan Circle)
            const groundIconGeometry = new THREE.SphereGeometry(15 / sceneScale, 16, 16);
            const groundIconMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff }); // Cyan
            groundTrackIcon = new THREE.Mesh(groundIconGeometry, groundIconMaterial);
            scene.add(groundTrackIcon);
        }


        function finalizeScene() {
            drawGroundTrack();
            calculateAndDisplayPasses();
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = earthRadius / sceneScale * 1.01; // Allow closer zoom
            controls.maxDistance = earthRadius / sceneScale * 5;

            document.getElementById('loader').style.display = 'none';
            document.getElementById('info-panel').style.display = 'block';
            document.getElementById('instructions').style.display = 'block';

            animate();
        }
        
        function drawGroundTrack() {
            const groundPositions = [];
            const totalMinutes = 540;
            const stepMinutes = 1;
            const startTime = tleEpochToDate(satrec);
            const radius = earthRadius / sceneScale + 1.5 / sceneScale; // Slightly above surface to avoid z-fighting

            for (let i = 0; i < totalMinutes; i += stepMinutes) {
                const time = new Date(startTime.getTime() + i * 60 * 1000);
                const positionAndVelocity = satellite.propagate(satrec, time);
                const positionEci = positionAndVelocity.position;

                if (!positionEci) break;

                const gmst = satellite.gstime(time);
                const geodetic = satellite.eciToGeodetic(positionEci, gmst);

                if (geodetic.height < 0) break;

                const lat = geodetic.latitude; // radians
                const lon = geodetic.longitude; // radians

                // Convert lat/lon to 3D coordinates on the sphere surface
                const x = radius * Math.cos(lat) * Math.cos(lon);
                const y = radius * Math.cos(lat) * Math.sin(lon);
                const z = radius * Math.sin(lat);

                // Re-orient to match the scene's coordinate system (Y-up)
                groundPositions.push(new THREE.Vector3(x, z, -y));
            }

            if (groundPositions.length < 2) return;

            const geometry = new THREE.BufferGeometry().setFromPoints(groundPositions);
            const material = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 }); // Cyan
            const groundTrack = new THREE.Line(geometry, material);
            scene.add(groundTrack);
        }

        function isOverMalaysia(geodetic) {
            const latitude = satellite.degreesLat(geodetic.latitude);
            const longitude = satellite.degreesLong(geodetic.longitude);
            return (
                latitude >= MALAYSIA_BOUNDS.minLat &&
                latitude <= MALAYSIA_BOUNDS.maxLat &&
                longitude >= MALAYSIA_BOUNDS.minLon &&
                longitude <= MALAYSIA_BOUNDS.maxLon
            );
        }

        function toMalaysiaTime(utcDate) {
            // Malaysia is UTC+8
            const offset = 8 * 60 * 60 * 1000;
            const localTime = new Date(utcDate.getTime() + offset);
            return localTime.toLocaleString('en-GB', { timeZone: 'UTC', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true });
        }
        
        function calculateAndDisplayPasses() {
            const passList = document.getElementById('pass-list');
            passList.innerHTML = ''; // Clear "Calculating..."
            
            const passes = [];
            let wasOver = false;
            let entryTime = null;

            const totalMinutes = 540;
            const stepMinutes = 0.2; // Increase resolution for more accurate times
            const startTime = tleEpochToDate(satrec);
            
            for (let i = 0; i < totalMinutes; i += stepMinutes) {
                const time = new Date(startTime.getTime() + i * 60 * 1000);
                const positionAndVelocity = satellite.propagate(satrec, time);
                if (!positionAndVelocity.position) break;

                const gmst = satellite.gstime(time);
                const geodetic = satellite.eciToGeodetic(positionAndVelocity.position, gmst);
                
                if (geodetic.height < 0) break;

                const isOver = isOverMalaysia(geodetic);
                
                if (isOver && !wasOver) {
                    entryTime = time;
                }
                
                if (!isOver && wasOver && entryTime) {
                    passes.push({ entry: entryTime, exit: time });
                    entryTime = null;
                }
                wasOver = isOver;
            }
            
            const futurePasses = passes.filter(pass => pass.entry > currentUserTimeUTC);

            if (futurePasses.length === 0) {
                 if (passes.length > 0) {
                    passList.innerHTML = '<li>No future passes detected. Satellite has likely reentered.</li>';
                } else {
                    passList.innerHTML = '<li>No passes detected.</li>';
                }
            } else {
                futurePasses.forEach(pass => {
                    const li = document.createElement('li');
                    li.textContent = `Entry: ${toMalaysiaTime(pass.entry)} - Exit: ${toMalaysiaTime(pass.exit)}`;
                    passList.appendChild(li);
                });
            }
        }

        function updateSatellitePosition(time) {
            if (!satelliteObj) return;
            
            const positionAndVelocity = satellite.propagate(satrec, time);
            const positionEci = positionAndVelocity.position;
            const velocityEci = positionAndVelocity.velocity;

            if (!positionEci) {
                satelliteObj.visible = false;
                if (groundTrackIcon) groundTrackIcon.visible = false;
                if(document.getElementById('status').textContent !== 'Reentered') {
                    document.getElementById('status').textContent = 'Reentered';
                    document.getElementById('status').style.color = '#ff4d4d';
                }
                return;
            }

            const gmst = satellite.gstime(time);
            const geodetic = satellite.eciToGeodetic(positionEci, gmst);

            const latitude = satellite.degreesLat(geodetic.latitude);
            const longitude = satellite.degreesLong(geodetic.longitude);
            const altitude = geodetic.height;
            const velocity = Math.sqrt(Math.pow(velocityEci.x, 2) + Math.pow(velocityEci.y, 2) + Math.pow(velocityEci.z, 2));

            lastGeodeticData = { latitude, longitude, altitude, velocity };
            
            const positionEcf = satellite.eciToEcf(positionEci, gmst);
            satelliteObj.position.set(positionEcf.x / sceneScale, positionEcf.z / sceneScale, -positionEcf.y / sceneScale);

            // Update ground track icon position and color
            if (groundTrackIcon) {
                const radius = earthRadius / sceneScale + 1.5 / sceneScale; // Slightly above surface
                const lat = geodetic.latitude; // radians
                const lon = geodetic.longitude; // radians

                const x = radius * Math.cos(lat) * Math.cos(lon);
                const y = radius * Math.cos(lat) * Math.sin(lon);
                const z = radius * Math.sin(lat);

                groundTrackIcon.position.set(x, z, -y);
                groundTrackIcon.material.color.setHex(isOverMalaysia(geodetic) ? 0x00ff00 : 0x00ffff);
            }

            document.getElementById('lat').textContent = latitude.toFixed(2);
            document.getElementById('lon').textContent = longitude.toFixed(2);
            document.getElementById('alt').textContent = altitude.toFixed(2);
            document.getElementById('vel').textContent = velocity.toFixed(2);
            
            if (altitude < 100) {
                if(document.getElementById('status').textContent !== 'Reentry imminent!') {
                    document.getElementById('status').textContent = 'Reentry imminent!';
                    document.getElementById('status').style.color = '#ff4d4d';
                }
            } else {
                 if(document.getElementById('status').textContent !== 'Simulating Final Orbits') {
                    document.getElementById('status').textContent = 'Simulating Final Orbits';
                    document.getElementById('status').style.color = '#4caf50';
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            css2dRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const simulationSpeed = 600;
            simulationTime.setTime(simulationTime.getTime() + delta * 1000 * simulationSpeed);

            controls.update();
            if (earth) earth.rotation.y += 0.0001;
            if (clouds) clouds.rotation.y += 0.00015;
            
            updateSatellitePosition(simulationTime);
            renderer.render(scene, camera);
            css2dRenderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>

